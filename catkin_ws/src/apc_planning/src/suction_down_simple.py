# suction down primitive:

# inputs:
# Pose and position of the object, object ID, shelf pose, position and force
# threshold for grasp.

# fails:
# # The vertical dimension of the object should be smaller than the maximum
# gap distance between the two fingers.

import tf
import numpy as np
from manual_fit.srv import * 
from pr_msgs.msg import * 
import rospy
import time
from visualization_msgs.msg import MarkerArray, Marker
from apc.helper import UpdateCommand
import scorpion

if __name__ == "__main__":

    rospy.init_node('suction_down_simple', log_level = rospy.INFO)

import sensor_msgs.msg
import os
import sys
sys.path.append(os.environ['ARC_BASE'] + '/catkin_ws/src/weight_sensor/src')
import ws_prob
from pr_msgs.srv import SuctionData1
import roslib; roslib.load_manifest("robot_comm")
from robot_comm.srv import * 
from visualization_msgs.msg import * 
import copy
from collision_detection.collisionHelper import * 
from collision_free_placing import collision_free_placing, is_in_bin
from rospy import ROSException
from rospy import Publisher
from ik.roshelper import ROS_Wait_For_Msg
from ik.ik import IK
from ik.ik import IKGuarded
from ik.ik import SuctionGuard
from ik.ik import WeightGuard
from ik.ik import getCart
from gripper import close
from ik.ik import fastfk
from ik.ik import setAcc
from ik.helper import createDeleteAllMarker, deleteMarkers
# put shared function into ik.helper module
from ik.helper import pauseFunc
from ik.helper import quat_from_matrix
from ik.helper import plotPickPoints
from ik.helper import get_joints
from ik.helper import get_tcp_pose

import tf.transformations as tfm
from std_msgs.msg import Float64
from std_msgs.msg import Bool
from std_srvs.srv import Empty, EmptyResponse

#import suction_projection
from suction_projection import suction_projection_func
from suction_projection import optimize_angle
import suction
from ik.helper import pose_transform_precise_placing
from ik.helper import vision_transform_precise_placing
from collision_detection.collisionHelper import * 
import matplotlib.pyplot as plt
from ik.roshelper import poseTransform, pubFrame
from goToHome import prepGripperSuction
from suction_publisher_flow import read_flow_level

haverobot = rospy.get_param('/have_robot', True) #TODO: Maybe put inside the required function
haveraspberry = rospy.get_param('/use_raspberry', True)

#Robot Position is in the form [forward/back ( + is away from robot), 
#left/right ( + is towards the door), up/down ( + is up)]
#home position of the system
#base position is at a fixed location above the tote
# if withPause is true, robot will pause after every motion and wait for a button press during execution
# suction_position_target is the desired position of the suction cup in the world frame
# + x direction is forward
# + y direction is to robot left
# + z direction is up
# flag determines which mode to use
# flag = 0: pick up object (turn on suction at that point)
# flag = 1: go to base position
# flag = 2: drop object (at suction point)
# flag = 3: go to vac calibration position
# bin_id is which bin to look at:
# 0 is tote (right bin) and 1, 2, 3 are 2nd, 3rd and 4th bins starting from the right
# return values (plan_success, suction_check)
# plan success is true if the planner succeeded in planning, false otherwise
# success_flag is whether the plan is feasible or not, True for success, false otherwise
# suction_check is true if the object is attached to the suction cup at the end of the primitive
# vac_level_before_contact is the value of vaccuum level right before approaching target
# vac_level_after_contact is the value of vaccuum level right after approaching target
# print_messages is whether or not the primitive should print stuff
# 'vac_level_before', 'vac_level_after' and 'suction_check'  initialed as 'None'
# Removed unused input: 'input_speed'  'tote_bounds' and 'run_real'
#rel_pose and BoxBody are inputs generated by ik.helper.vision_transform_precise_placing
#place_pose is the desired pos of the object being placed in the world frame

def suction_down_simple(listener, br, withPause = True, suction_position_target_list = [[ - 3, - 5, - 5]], 
    flag = 0, bin_id = 0, print_messages = False, obj_ID = 'avery_binder', rel_pose = None, BoxBody = None, 
    place_pose = None, box_height = 0.1, viz_pub = None, is_drop = False, update_command = None,go_faster_flag = False):

    rospy.logdebug('[Suction] withPause = %d ', withPause)
    rospy.logdebug('[Suction] suction_position_target_list = %s', suction_position_target_list)
    rospy.logdebug('[Suction] flag = %d ', flag)
    rospy.logdebug('[Suction] bin_id = %d', bin_id)
    rospy.logdebug('[Suction] print_messages = %s', print_messages)
    rospy.logdebug('[Suction] obj_ID = %s', obj_ID)
    rospy.logdebug('[Suction] rel_pose = %s', rel_pose)
    rospy.logdebug('[Suction] BoxBody = %s', BoxBody)
    rospy.logdebug('[Suction] place_pose = %s', place_pose)
    rospy.logdebug('[Suction] box_height = %s ', box_height)
    rospy.loginfo('[Suction] Called with ------- flag = %d ------ ', flag)

    
    tip_hand_dis = rospy.get_param('/suction_tube/suction/length')
    suction_cup_offset_x = rospy.get_param('/scorpion_tail/suction/x_offset')  # in world frame
    suction_cup_offset_y = rospy.get_param('/scorpion_tail/suction/y_offset')  # in world frame
    gripper_dimensions = rospy.get_param('gripper')
    finger_dimensions = rospy.get_param('finger') #{thickness:, width:, length:, spatula_length:}
    wrist_dimensions = rospy.get_param('wrist') #{length:}
    tote_dimensions = rospy.get_param('tote') #{height:, width:, length: }
    vision_pose_suction = rospy.get_param('vision_pose_suction') #{x:, y:, z: }
    bin_pose = rospy.get_param('bin' + str(bin_id) + '_pose') #TODO: Modify the pose as you want. It is a dictionary:{qw:, qx:, qy:, qz:, x:, y:, z:}
    bin3_pose = rospy.get_param('bin' + str(3) + '_pose')
    try:
        obj_dim = rospy.get_param('obj')[str(obj_ID)]
        go_slow = obj_dim['slow_move']   # check it with Eudald
    except:
        go_slow = True

    #withPause = True
    #pauseFunc(withPause)
    output_dic = {}
    joint_topic = '/joint_states'
    joint6_mid_angle = 0.0
    suc_down_orientation_base = [0.0, 1.0, 0.0, 0.0]
    isSuction = True
    tcp_pos = [0.0, 0.0, 0.0]
    finger_opening = 0.0
    final_object_pose = None
    weight_lifted = 0.0
    horizontal_safety_margin = .005
    height_margin = 0.03 #for dropping
    tilted_travel = .08
    lowest_bound = 0.32
    highest_bound = 0.60
    floor_margin = 0.02
    idx = 0
    success_flag = False
    suction_check = False
    flow_level = 0.0
    aggressive_threshold_flow_level = 0.25
    aggressive_threshold_weight = 200
    ws_check = False
    any_plan_found = False
    goto_vision_position = False
    arrived_vision_position = False
    suc_down_orientation = None
    first_run = True
    map_bin_id_to_ws_id = {0:0, 1:1, 2:2, 3:3, 4:0, 5:0, 6:4, 7:4, 8:5}
    pick_succeed = False
    

    if type(suction_position_target_list[0]) != list:
        suction_position_target_list = [suction_position_target_list]

    #############################
    ### The system dimensions ###
    #############################

    MaxRetryNum = len(suction_position_target_list)
    is_pick = flag == 0 or flag == 3
    if is_pick:
        go_faster_flag = False
        go_slow = True
    tip_hand_transform = [0.0, 0.0, tip_hand_dis, 0.0, 0.0, 0.0, 1.0]
    suction_cup_offset = [suction_cup_offset_x, suction_cup_offset_y, 0.0]
    tip_hand_transform_suction_cup = [ - suction_cup_offset_x, suction_cup_offset_y, tip_hand_dis, 0.0, 0.0, 0.0, 1.0]
    hand_orient_norm = tfm.quaternion_matrix(suc_down_orientation_base)[0:3, 0:3]
    finger_pts = getFingerPoints(finger_opening, tcp_pos, hand_orient_norm, isSuction)
    wristPoints = getWristPoints(tcp_pos, hand_orient_norm, isSuction)
    bin_pts = getBinPoints(binId = bin_id, listener = listener, br = br, isSuction = isSuction)
    bin_floor = min(bin_pts[:, 2])
    bin_centroid = 1.0 * np.array([bin_pose['x'], bin_pose['y'], bin_pose['z']])
    vision_pos = 1.0 * np.array([vision_pose_suction['x'], vision_pose_suction['y'], vision_pose_suction['z']])
    cup_in_tote_zone = poseTransform(tip_hand_transform_suction_cup, "link_6", "map", listener)[0] > 0.54
    if bin_id == 0 or bin_id == 1 or bin_id ==2:
        in_bin_moving_height = bin_centroid[2] + 0.06
    else:
        in_bin_moving_height = bin_centroid[2] + 0.06 + max(bin3_pose['z'] - bin_pose['z'] , 0.0)
    min_drop_height = select_func(.14, .07, is_drop and flag == 2)
    starting_height = select_func(0.40, 0.0, not cup_in_tote_zone or bin_id == 6 or bin_id == 7 or bin_id == 8)
    base_height = 0.30
    suction_position_base = np.array([bin_centroid[0], bin_centroid[1], starting_height + base_height])
    #~ if bin_id < 6:
        #~ active_position_base = bin_centroid + vision_pos - [0.0, 0.0, bin_centroid[2]]
    #~ else:
    if bin_id in (0,1,2,3,4,5):
        active_position_base = bin_centroid + vision_pos - [0.0, 0.0, bin_centroid[2]]
    #~ elif bin_id == 3:
        #~ active_position_base = bin_centroid + vision_pos
    else:
        active_position_base = bin_centroid + [0.0,0.0,0.42] - [0.0, 0.0, bin_centroid[2]]
    print 'active_position_base[2]',active_position_base[2]
    with_object = flag == 2 or flag == 1

    rospy.logdebug('suction_position_base = %s', suction_position_base)


    

    ###########################
    ### Begin suction work  ###
    ###########################

    if is_pick:
        suction.start()

    while idx < MaxRetryNum or flag == 1:
        if flag == 0:
            scorpion.fastfwd()
        flag_loop_start = flag

        if is_pick:
            plotPickPoints(suction_position_target_list, viz_pub, idx)

            
        ###########################
        ### Inloop: Preparation ###
        ###########################

        if flag != 1:
            suction_position_target = suction_position_target_list[idx]
            suction_position_target = 1.0 * np.array([suction_position_target[0],suction_position_target[1],max(bin_floor, suction_position_target[2])])
            rospy.loginfo('[Suction] Going for Candidate. -- %d -- in target_list', idx)
            rospy.loginfo('[Suction] suction_position_target proposed by planner %s', suction_position_target)
            
        

        #############################
        ### Inloop: setting paras ###
        #############################
        
        
        myPlan = suctionPlan()

        if flag == 0:
            theta = best_angle(np.array(suction_position_target[0:2], ndmin = 2), suction_cup_offset, bin_pts, finger_pts, margin = horizontal_safety_margin)
            orient_mat_4x4 = [[np.cos(theta), - np.sin(theta), 0, 0], [np.sin(theta), np.cos(theta), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
            suc_down_orientation = quat_from_matrix(np.dot(orient_mat_4x4, tfm.quaternion_matrix(suc_down_orientation_base)))
            (suction_position_target_projected, target_nearest) = project_position(suction_position_target, suction_cup_offset, bin_pts, finger_pts, theta, False, horizontal_safety_margin)
            suction_position1 = [suction_position_target_projected[0], suction_position_target_projected[1], bin_floor-floor_margin]
            suction_check_pos = [suction_position_target_projected[0], suction_position_target_projected[1], in_bin_moving_height]
            myPlan.orientation_list = [suc_down_orientation] * 15
            myPlan.transform_list = [tip_hand_transform] * 15
            myPlan.position_list = [suction_check_pos, suction_position1, suction_check_pos]
            myPlan.name_list = ['suction_check_pos', 'suction_position1', 'suction_check_pos']
            myPlan.input_speed_list = ['superSaiyan', 'faster', 'faster']
            myPlan.s_on_list[0] = True
            myPlan.guarded_list[1] = [WeightGuard(map_bin_id_to_ws_id[bin_id]), 1]
            myPlan.acc_list[1] = True
            myPlan.calib_fs_list[0] = not any_plan_found

        elif flag==1:
            myPlan.orientation_list = [get_tcp_pose(listener, tcp_offset = 0.0)[3:7]] * 15
            myPlan.transform_list = [tip_hand_transform_suction_cup] * 15
            myPlan.position_list = [active_position_base]
            myPlan.name_list = ['active_position_base']
            if is_pick:
                if flow_level > aggressive_threshold_flow_level and weight_lifted < aggressive_threshold_weight:
                    rospy.logwarn("[Suction] flow_level=%s and  weight_lifted = %s!! Go yolo~",flow_level,weight_lifted)
                    go_faster_flag = True
                elif suction_check == False and not ws_check:
                    rospy.logwarn("[Suction] No object in hand, suction_check = %s,ws_check = %s!! Go yolo~",suction_check,ws_check)
                    go_faster_flag = True
                    go_slow = False
                else:
                    go_faster_flag = False
                    
            if go_faster_flag and not go_slow:
                rospy.logwarn("[Suction] go_faster_flag is True!! Go yolo~")
                myPlan.input_speed_list = ['yolo']
            else:
                myPlan.input_speed_list = ['faster']
            myPlan.acc_list[0] = True

        elif flag == 2:
            horizontal_safety_margin = .03
            pre_drop_height = min(max(bin_pts[:, 2]) + height_margin, suction_position_base[2])
            (new_drop_pose, final_object_pose) = pose_transform_precise_placing(rel_pose, BoxBody, place_pose, 
                [0.0, 0.0, 0.0] + suc_down_orientation_base, bin_pts, finger_pts, horizontal_safety_margin, False, viz_pub)
            suction_position_target = [new_drop_pose[0], new_drop_pose[1], bin_floor + min_drop_height]
            suc_down_orientation = new_drop_pose[3:7]
            rospy.logdebug('[Suction] new_drop_pose %s', new_drop_pose)
            pre_drop_pos = np.array([suction_position_target[0], suction_position_target[1], pre_drop_height])
            suction_position_base = [pre_drop_pos[0], pre_drop_pos[1], suction_position_base[2]]
            myPlan.orientation_list = [suc_down_orientation] * 15
            myPlan.transform_list = [tip_hand_transform] * 15
            if bin_id < 5:
                suction_position_base[2] = active_position_base[2]
            else:
                suction_position_base[2] = in_bin_moving_height+0.05
                active_position_base[2] = max(active_position_base[2],in_bin_moving_height+0.05)
            
            myPlan.position_list = [pre_drop_pos, suction_position_target, suction_position_base,active_position_base]
            myPlan.name_list = ['pre_drop_pos', 'suction_position_target', 'suction_position_base','active_position_base']
            myPlan.s_off_list[1] = True
            myPlan.s_on_list[2] = True         #TO DO: turning on is never called 
            myPlan.guarded_list = [None, [WeightGuard(map_bin_id_to_ws_id[bin_id]), 1], None,None]
            
            if go_faster_flag and not go_slow:
                rospy.logwarn("[Suction] go_faster_flag is True!! Go yolo~")
                myPlan.input_speed_list = ['yolo', 'superSaiyan', 'superSaiyan','superSaiyan']
            else:
                myPlan.input_speed_list = ['faster', 'superSaiyan', 'superSaiyan','superSaiyan']
            myPlan.acc_list = [True, True, False, False]

        elif flag == 3:
            (position_list, name_list, orientation_list) = suction_tilt_projection(suction_position_target,bin_id=bin_id)
            myPlan.position_list = position_list
            myPlan.name_list = name_list
            myPlan.orientation_list = orientation_list
            myPlan.transform_list = [tip_hand_transform_suction_cup] * 15
            myPlan.s_on_list[0] = True
            myPlan.guarded_list[4] = [WeightGuard(map_bin_id_to_ws_id[bin_id]), 3]
            myPlan.guarded_list[5] = [WeightGuard(map_bin_id_to_ws_id[bin_id]), 1]
            myPlan.acc_list[5] = True
            myPlan.calib_fs_list[3] = True
            myPlan.input_speed_list[0:2] = ['superSaiyan', 'superSaiyan', 'superSaiyan']

        if is_pick and flag != 1:
            weight_info_ini = read_weight(map_bin_id_to_ws_id[bin_id])
            rospy.loginfo("[Suction] weight_info_ini = %s", weight_info_ini)

        ###########################
        ### Safely move to bin  ###
        ###########################
        rospy.loginfo('[Suction] Going to bin -- %d -- ', bin_id)

        pauseFunc(withPause)
        if first_run:
            q0 = collision_free_placing(binId = bin_id, listener = listener, obj_ID = obj_ID, BoxBody = BoxBody, isSuction = True, with_object = with_object, hand_orientation = myPlan.orientation_list[0], projected_target_position = myPlan.position_list[0], isReturn = True, tip_hand_transform = myPlan.transform_list[0],go_faster_flag=go_faster_flag)
            if update_command is not None:
                update_command.execute()
            q0_list = list(q0)
            #q0_list[5] = (joint6_mid_angle * np.pi) / 180.0
            q0 = tuple(q0_list) 

        #########################################
        ### Inloop: Generate and execute plan ###
        #########################################

        rospy.logdebug('[Suction] q0 = %s', q0)

        myPlan.withPause = withPause
        myPlan.q0 = q0
        myPlan.haverobot = haverobot

        success_flag = myPlan.generatePlan()
        any_plan_found = any_plan_found or success_flag
        
        if myPlan.plans != []: 
        #~ if success_flag:
            q0 = myPlan.qf
            q0_list = list(q0)
            #q0_list[5] = (joint6_mid_angle * np.pi) / 180.0
            q0 = tuple(q0_list)
            myPlan.executePlan()
            if is_pick and flag != 1:
                suction_check = read_engaged_status()
                if haverobot:
                    flow_level = read_flow_level()
                weight_info_post = read_weight(map_bin_id_to_ws_id[bin_id])
                rospy.logdebug('[ Suction ]suction_check = %s', suction_check)
                rospy.loginfo("[Suction] weight_info_post = %s", weight_info_post)
                weight_lifted = weight_info_ini - weight_info_post
                ws_check = weight_check_suction(w_ini = weight_info_ini, w_post = weight_info_post)
                if (suction_check == True or ws_check == True) and haverobot:
                    flag = 1   # go to active_vision position
                    
                if suction_check == False and ws_check == True:  # kind of hack
                    suction_check = None
            #~ else:
                #~ flag = 1
        else:
            rospy.logwarn('[Suction] success_flag is not True (motion planning failed)')
        
        if not success_flag and flag==2:
            suction.stop()

        if (idx == MaxRetryNum - 1) and is_pick:
            flag = 1   # go to active_vision position

        deleteMarkers(viz_pub, '')
        idx = idx + 1

        if flag_loop_start == 1:
            break

        first_run = False
    
    if flag==2:
        suction.start()   # Just to 100% make sure that suction is turned on after placing
        setAcc(4,4)
    
    output_dic["ws_check"] = ws_check
    output_dic["weight_lifted"] = weight_lifted
    output_dic["final_object_pose"] = final_object_pose
    output_dic["success_flag"] = success_flag
    output_dic["suction_check"] = suction_check
    output_dic["flow_level"] = flow_level
    output_dic["go_faster_flag"] = go_faster_flag
    return output_dic

class suctionPlan():
    def __init__(self):
        self.name_list = None
        self.withPause = False
        self.orientation_list = [None] * 15
        self.position_list = [None] * 15
        self.s_off_list = [False] * 15
        self.s_on_list = [False] * 15
        self.guarded_list = [None] * 15
        self.acc_list = [False] * 15
        self.input_speed_list = ['faster'] * 15
        self.calib_fs_list = [False] * 15
        self.bail_out_speed = 'faster'
        self.transform_list = []
        self.q0 = None
        self.qf = None
        self.qf_list = []
        self.plans = []
        self.bail_out_plans = []
        self.haverobot = False
        self.print_messages = False
        self.bail_out_plans = []

    def generatePlan(self):
        success_flag = True
        self.plans = []

        self.qf = self.q0
        for i in range(0, len(self.position_list)):
            #compute the plan that moves the robot from pose q0 to pose [target_tip_pos, target_tip_ori]
            #specifically, we are moving the suction cup, whose relative location to link6 is determined by tip_hand_transform

            if self.guarded_list[i] is not None and haverobot:
                planner = IKGuarded(q0 = self.qf, target_tip_pos = self.position_list[i], target_tip_ori = self.orientation_list[i], 
                                    tip_hand_transform = self.transform_list[i], joint_topic = '/joint_states', guarded_obj = self.guarded_list[i][0], weight = [1, 8, 1, 2, 1, 10])
    
                next_index = i + self.guarded_list[i][1]

                bail_out_planner = IK(q0 = self.qf, target_tip_pos = self.position_list[next_index], target_tip_ori = self.orientation_list[next_index], 
                             tip_hand_transform = self.transform_list[next_index], joint_topic = '/joint_states', useFastIK = True, weight = [1, 8, 1, 2, 1, 10])
            else:
                planner = IK(q0 = self.qf, target_tip_pos = self.position_list[i], target_tip_ori = self.orientation_list[i], 
                             tip_hand_transform = self.transform_list[i], joint_topic = '/joint_states', useFastIK = True, weight = [1, 8, 1, 2, 1, 10])
                bail_out_planner = None

            plan = planner.plan()
            #if  IK works for the current step, append it to the plan list, otherwise break
            if plan.success():  # whether or not IK actually worked
                plan.setSpeedByName(self.input_speed_list[i])
                self.plans.append(plan)
                #the current final position of the plan sequence is stored in qf
                self.qf = copy.deepcopy(plan.q_traj[len(plan.q_traj) - 1])
                if not check_joints(self.qf):
                    success_flag = False
                    rospy.logerr('[Suction] Planned joint out of range, breaking...')
                    break
                self.qf_list.append(self.qf)
            else:
                success_flag = False
                rospy.logwarn('[Suction] STEP %d: plan failure at %s %s', i, self.name_list[i], self.position_list[i])
                rospy.logdebug('         with orientation = %s', self.orientation_list[i])
                break

            if bail_out_planner == None:
                self.bail_out_plans.append(None)
            else:
                bail_out_plan = bail_out_planner.plan()
                if bail_out_plan.success():
                    bail_out_plan.setSpeedByName(self.bail_out_speed)
                    self.bail_out_plans.append(bail_out_plan)
                else:
                    success_flag = False
                    rospy.logerr('[Suction] bail_out_plan failure')
                    break

        return success_flag
    def executePlan(self):
        i = 0

        while i < len(self.plans):
            rospy.loginfo('[Suction] STEP %d : Going to %s: %s', i, self.name_list[i], self.position_list[i])
            plan = self.plans[i]
            plan.visualize(hand_param = 0) # visualize  this step in RViz

            #~ if self.s_on_list[i]:
                #~ pre_calibrate_flow_sensor()

            if haverobot and self.calib_fs_list[i]:
                while read_calib_status() != True:
                    rospy.sleep(0.1)
                #~ calibrate_flow_sensor()

            if self.acc_list[i]:
                setAcc(1, 1)
            else:
                setAcc(4, 4)

            rospy.logdebug('[Suction] self.input_speed_list[i]%s', self.input_speed_list[i]) 
            rospy.logdebug('[Suction]%s = %s', self.name_list[i], self.position_list[i])
            rospy.logdebug('           with orientation = %s', self.orientation_list[i])

            pauseFunc(self.withPause) # this makes it so that you have to press enter before the plan will run
            plan.execute() #this executes a given plan (move from joint angle A to angles B associated with that plan)
            if self.s_on_list[i]:
                print '[ Suction ] Turning suction on'
                suction.start()
            if self.s_off_list[i]:
                print '[ Suction ] Turning suction off'
                suction.stop()
            if plan.is_guarded() and not plan.plan_finished():
                if self.print_messages:
                    print 'collision point'
                    print i
                plan.executeBackward()
                pauseFunc(self.withPause)
                self.bail_out_plans[i].execute()

                i = i + self.guarded_list[i][1]

            i = i + 1

def select_func(A,B,X):
    if X==True:
        return A
    else:
        return B

def weight_check_suction(w_ini = 0, w_post = 0):
    w_diff = w_ini - w_post
    if w_diff > 10:
        weight_check = True
    elif w_diff > 1:
        weight_check = None
    else:
        weight_check = False
    return weight_check

def interp_pos(pos1, pos2, alpha):
    pos1 = np.array(pos1)
    pos2 = np.array(pos2)
    return (1 - alpha) * pos1 + alpha * pos2

def read_weight(weight_sensor_id):
    if haverobot:
        try:
            msg = rospy.wait_for_message('/ws_stream' + str(weight_sensor_id), Bool, 6)
            engaged_status = msg.data
        except ROSException:
            print ROSException.message
            print("[Suction] Cannot read weight")
            return 0
        return engaged_status
    else:
        'Robot not connected, Skipping read weight_sensor'
        return 0

def read_calib_status():
    if haverobot:
        try:
            msg = rospy.wait_for_message("/flow_calib_status", Bool, 3)
            flow_calib_status = msg.data
        except ROSException:
            print ROSException.message
            print("Cannot read flow_calib_status")
            return None
        return flow_calib_status
    else:
        'Suction not connected, Skipping read_engaged_status check'
        return None
        
def read_engaged_status():
    if haverobot:
        try:
            msg = rospy.wait_for_message("/vac_engaged", Bool, 6)
            engaged_status = msg.data
            return engaged_status
        except ROSException:
            print ROSException.message
            print("Cannot read vac_engaged")
            return None
    else:
        'Suction not connected, Skipping read_engaged_status check'
        return None

def check_joints(qf):
    joint_limits = [
    [ - 2.35619449019, 2.35619449019], 
    [ - 1.57079632679, 2.61799387799], 
    [ - 4.15388361975, 1.37881010908], 
    [ - 2.70526034059, 2.70526034059], 
    [ - 1.57079632679, 2.35619449019], 
    [ - 500.0 * np.pi / 180, 500.0 * np.pi / 180]]
    bound_test = True
    for i in range(0, len(qf)):
        if qf[i] < joint_limits[i][0] or joint_limits[i][1] < qf[i]:
            bound_test = False
            break
    return bound_test

def best_angle(pos_in, pivot_pos, bin_pts, finger_pts, margin = 0):
    theta_ideal=-np.pi/2
    (shape_translation, dist_val, found_feasible, nearest_point, theta_min) = optimize_angle(bin_pts[:, 0:2], finger_pts[:, 0:2], np.array(pos_in[0:2], ndmin = 2), np.array(pivot_pos[0:2], ndmin = 2), np.linspace(theta_ideal, theta_ideal + 2 * np.pi, 25), show_plot = False, margin = margin)
    return theta_min

def project_position(pos_in, pivot_pos, bin_pts, finger_pts, theta, show_plot = False, margin = 0):
    pos_in = np.array(pos_in)
    vertical_margin = .05
    top_margin = .07

    (shape_translation, dist_val_min, feasible_solution, nearest_point) = suction_projection_func(bin_pts[:, 0:2], finger_pts[:, 0:2], np.array(pos_in[0:2], ndmin = 2), np.array(pivot_pos[0:2], ndmin = 2), theta, show_plot, margin)


    if feasible_solution:
        pos_in[0] = shape_translation[0]
        pos_in[1] = shape_translation[1]
    else:
        pos_in[0] = np.mean(bin_pts[:, 0])
        pos_in[1] = np.mean(bin_pts[:, 1])
    zmin = min(bin_pts[:, 2]) + vertical_margin
    zmax = max(bin_pts[:, 2]) + top_margin
    #bottom bound on position
    pos_in[2] = max(pos_in[2], zmin)
    #top bound on position
    pos_in[2] = min(pos_in[2], zmax)

    return (pos_in, nearest_point)

calibrate_fs = rospy.ServiceProxy('flow_sensor_calibration', Empty)
def calibrate_flow_sensor():
    if haverobot:
        calibrate_fs()
        rospy.loginfo('[Suction] Flow_sensor calibration complete')
    else:
        rospy.logwarn('[Suction] Flow_sensor not connected, skipping calibrate_flow_sensor')

pre_calibrate_fs = rospy.ServiceProxy('flow_sensor_empty_buffer', Empty)
def pre_calibrate_flow_sensor():
    if haverobot:
        pre_calibrate_fs()
        rospy.loginfo('[Suction] Flow_sensor buffer emptied')
    else:
        rospy.logwarn('[Suction] Flow_sensor not connected, skipping pre_calibrate_flow_sensor')

def test_bounds(listener, br, bin_num = 0, pos_num = 0):

    suction_position_target_in_list = [
    [ - 5, - 5, - 5], 
    [5, 5, - 5], 
    [5, - 5, - 5], 
    [ - 5, 5, - 5], 
    [0, 0, - 5]]

    for suction_position_target_in in suction_position_target_in_list:


        suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target = suction_position_target_in, 
        flag = 0, bin_id = bin_num, print_messages = True)

        time.sleep(.25)
        suction.stop()

def spherical_to_quaternion(theta, phi):
    psi = 3 * np.pi / 2
    suc_down_orientation_base = [0.0, 1.0, 0.0, 0.0]

    orient_mat_phi = [[np.cos(phi), 0, np.sin(phi), 0], [0, 1, 0, 0], [ - np.sin(phi), 0, np.cos(phi), 0], [0, 0, 0, 1]]
    orient_mat_theta = [[np.cos(theta), - np.sin(theta), 0, 0], [np.sin(theta), np.cos(theta), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
    orient_mat_psi = [[np.cos(psi), - np.sin(psi), 0, 0], [np.sin(psi), np.cos(psi), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]

    orient_mat_candidate = np.dot(orient_mat_theta, np.dot(orient_mat_phi, orient_mat_psi))
    absolute_orient_mat_candidate = np.dot(orient_mat_candidate, tfm.quaternion_matrix(suc_down_orientation_base))
    quaternion_candidate = quat_from_matrix(absolute_orient_mat_candidate)

    return (quaternion_candidate, absolute_orient_mat_candidate)

def suction_tilt_projection(target_pos,bin_id=0):



    in_bin_moving_height_tilt = .1
    

    

    tilted_travel = .08
    tilted_travel_extra = .03

    x = target_pos[0]
    y = target_pos[1]
    z = target_pos[2]

    if bin_id == 0:
        bin_centroid = [.98, - .57, .004]

        y_left = - .41
        ymax = - .47
        ymin = - .7
        y_right = - .73

    if bin_id == 1:
        bin_centroid = [.98, - .1975, .004]

        y_left = - .03
        ymax = - .0975
        ymin = - .2975
        y_right = - .36
        
        

    binX = bin_centroid[0]
    binY = bin_centroid[1]
    binZ = bin_centroid[2]

    x_front = 1.24
    x_back = .7

    xmin = .75
    xmax = 1.2
    


    zmin = - .19
    zmax = 0.0



    x = max(min(x, x_front), x_back)
    y = max(min(y, y_left), y_right)

    dist_left = abs(y - y_left)
    dist_right = abs(y - y_right)
    dist_front = abs(x - x_front)
    dist_back = abs(x - x_back)

    side_vals = {'left':dist_left, 'right':dist_right, 'front':dist_front, 'back':dist_back}

    side_list = sorted(side_vals, key = side_vals.__getitem__)
    left_side = side_list[0] == 'left'
    right_side = side_list[0] == 'right'
    front_side = side_list[0] == 'front'
    back_side = side_list[0] == 'back'

    phi1 = 45 * np.pi / 180.0

    

    z_target = min(max(z, zmin), zmax)

    if left_side:
        x_target = max(min(x, xmax), xmin)

        y_target = y_left

        theta0 = - 90.0 * np.pi / 180.0
        phi0 = phi1

        if x_target <= .8:
            theta1 = - 75 * np.pi / 180.0
        elif x_target <= 1.13:
            theta1 = - 90 * np.pi / 180.0
        else:
            theta1 = - 105 * np.pi / 180.0

    if right_side:
        x_target = max(min(x, xmax), xmin)

        y_target = y_right

        phi0 = phi1


        theta0 = 90.0 * np.pi / 180.0
        if x_target <= .8:
            theta1 = 75 * np.pi / 180.0
        else:
            theta1 = 90 * np.pi / 180.0


    if front_side:
        y_target = max(min(y, ymax), ymin)

        x_target = x_front

        if bin_id == 0:
            phi1 = 37.5 * np.pi / 180.0
            phi0 = 0.0
        if bin_id == 1:
            phi1 = 42.0 * np.pi / 180.0
            phi0 = 0.0
            bin_centroid[1] = -.13

        theta0 = 180.0 * np.pi / 180.0
        theta1 = 180.0 * np.pi / 180.0


    if back_side:
        y_target = max(min(y, ymax), ymin)

        x_target = x_back

        phi1 = 37.5 * np.pi / 180.0
        phi0 = 0.0

        theta0 = 0.0 * np.pi / 180.0
        theta1 = 0.0 * np.pi / 180.0

    surface_normal = np.array([np.cos(theta1) * np.sin(phi1), np.sin(theta1) * np.sin(phi1), np.cos(phi1)])

    projected_target = np.array([x_target, y_target, z_target])

    suction_position2 = projected_target
    suction_position1 = suction_position2 + surface_normal * tilted_travel
    suction_position2 = suction_position2 - surface_normal * tilted_travel_extra

    suction_position0 = [suction_position1[0], suction_position1[1], in_bin_moving_height_tilt]

    if left_side and bin_id == 0:
        suction_position_base = [bin_centroid[0], max(bin_centroid[1], suction_position1[1]), in_bin_moving_height_tilt]
    else:
        suction_position_base = [bin_centroid[0], bin_centroid[1], in_bin_moving_height_tilt]
    suction_position_base_1 = [suction_position0[0], suction_position_base[1], suction_position_base[2]]



    theta_list = [theta0, theta0, theta1]
    phi_list = [0.0, phi0, phi1]
    suc_list = []
    for i in range(0, len(theta_list)):
        (suc_val, dummy) = spherical_to_quaternion(theta_list[i], phi_list[i])
        suc_list.append(suc_val)

    position_list = [suction_position_base, suction_position_base, suction_position_base_1, 
    suction_position0, suction_position1, suction_position2, suction_position1, suction_position0, suction_position_base_1, suction_position_base, suction_position_base]
    name_list = ['suction_position_base', 'suction_position_base', 'suction_position_base_1', 
    'suction_position0', 'suction_position1', 'suction_position2', 'suction_position1', 'suction_position0', 'suction_position_base_1', 'suction_position_base', 'suction_position_base']
    orientation_list = [suc_list[0], suc_list[1], suc_list[2], suc_list[2], suc_list[2], suc_list[2], suc_list[2], suc_list[2], suc_list[2], suc_list[1], suc_list[0]]


    return (position_list, name_list, orientation_list)


def test_tilt0(listener, br, bin_num = 0, side=0):

    viz_array_pub = Publisher('/visualization_marker_array', MarkerArray, queue_size = 200)
    rospy.sleep(0.5)

    y_left = - .41
    y_right = - .73
    x_front = 1.24
    x_back = .7

    target_list = []
    
    if side == 0:
        for x in np.linspace(x_back - .03, x_front + .03, 4):
            target_list.append([x, y_left, - .19])
            target_list.append([x, y_left, .0])
    if side == 1:
        for x in np.linspace(x_back - .03, x_front + .03, 4):
            target_list.append([x, y_right, - .19])
            target_list.append([x, y_right, .0])
    if side == 2:
        for y in np.linspace(y_right - .03, y_left + .03, 4):
            target_list.append([x_front, y, - .19])
            target_list.append([x_front, y, .0])
    if side == 3:
        for y in np.linspace(y_right - .03, y_left + .03, 4):
            target_list.append([x_back, y, - .19])
            target_list.append([x_back, y, .0])

    suction_down_simple(listener = listener, br = br, withPause = False, suction_position_target_list = target_list, flag = 3, bin_id = bin_num, print_messages = True, viz_pub = viz_array_pub)


    time.sleep(.25)
    suction.stop()

def test_tilt1(listener, br, bin_num = 0, side=0):

    viz_array_pub = Publisher('/visualization_marker_array', MarkerArray, queue_size = 200)
    rospy.sleep(0.5)

    y_left = - .03
    y_right = - .36
    x_front = 1.24
    x_back = .7

    target_list = []

    if side == 0:
        for y in np.linspace(y_right - .03, y_left + .03, 4):
            target_list.append([x_front, y, - .19])
            #target_list.append([x_front, y, - .095])
            target_list.append([x_front, y, .0])
    if side == 1:
        for x in np.linspace(x_back - .03, x_front + .03, 4):
            target_list.append([x, y_left, - .19])
            target_list.append([x, y_left, .0])
    if side == 2:
        for x in np.linspace(x_back - .03, x_front + .03, 4):
            target_list.append([x, y_right, - .19])
            target_list.append([x, y_right, .0])
    if side == 3:
        for y in np.linspace(y_right - .03, y_left + .03, 4):
            target_list.append([x_back, y, - .19])
            target_list.append([x_back, y, .0])

    suction_down_simple(listener = listener, br = br, withPause = False, suction_position_target_list = target_list, flag = 3, bin_id = bin_num, print_messages = True, viz_pub = viz_array_pub)


    time.sleep(.25)
    suction.stop()

def test_drop(listener, br):

        for bin_num in range(4):
            suction.start()
            suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target = [ - 5, - 5, - 5], flag = 2, bin_id = bin_num, print_messages = True, viz_pub = viz_array_pub)
            if haverobot:
                time.sleep(1)

def test_base(listener, br):
        for bin_num in range(4):
            suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target = [ - 5, - 5, - 5], flag = 1, bin_id = bin_num, print_messages = True, viz_pub = viz_array_pub)

def test_precise_placing(listener, br, bin_id, obj_ID = 'avery_binder', withPause = True,go_faster_flag=False):
    #~ prepGripperSuction()
    scale_box = 0.0
    #~ bbox_info = [0.0, 0.0, 0.0, 1.0] + [0.0, 0.0, 0.0] + [0.1 * scale_box, 0.15 * scale_box, 0.25 * scale_box]
    bbox_info =  [0.0, 0.0, -0.8188636302947998, 0.573988139629364, 0.8773503303527832, 0.5725569128990173, 0.2934170365333557, 0.18183177709579468, 0.1874466985464096, 0.05593683198094368]

    #~ place_pose = [5.0, 5.0, - 5, 0.0, 0.0, 0.0, 1.0]
    place_pose = [-0.1534, 0.5760, 0.4076, 0.0, 0.0, 0.0, 1.0]
    (rel_pose, BoxBody) = vision_transform_precise_placing(bbox_info, listener)
    #~ (rel_pose, BoxBody) = vision_transform_precise_placing(bbox_info, listener)
    rel_pose =  [-0.058294829032209283, 0.069896922125438299, 0.57747355552703217, -0.17315311679100356, 0.98489491344514779, -5.842525573719368e-05, -6.4822260305198183e-05]
    suction_down_simple(listener = listener, br = br, withPause = withPause, suction_position_target_list = [ - 3, - 5, - 5], flag = 2, bin_id = bin_id, print_messages = True, 
                rel_pose = rel_pose, BoxBody = BoxBody, place_pose = place_pose, box_height = 0.1, obj_ID = obj_ID,go_faster_flag=go_faster_flag)

def unit_test_placing(listener, br):
    #~ prepGripperSuction()
    scale_box = 0.0
    bbox_info = [0.0, 0.0, 0.0, 1.0] + [0.0, 0.0, 0.0] + [0.08 * scale_box, 0.15 * scale_box, 0.25 * scale_box]
    place_pose = [5.0, 5.0, - 5, 0.0, 0.0, 0.0, 1.0]
    for bin_id in range(0, 9):
        (rel_pose, BoxBody) = vision_transform_precise_placing(bbox_info, listener)
        suction_down_simple(listener = listener, br = br, withPause = False, suction_position_target_list = [ - 3, - 5, - 5], flag = 2, bin_id = bin_id, print_messages = True, 
                    rel_pose = rel_pose, BoxBody = BoxBody, place_pose = place_pose, box_height = 0.1)

def test_center_of_bin(listener, br, bin_num = 0, withPause = True):

    bin_pose = rospy.get_param('bin' + str(bin_num) + '_pose') #TODO: Modify the pose as you want. It is a dictionary:{qw:, qx:, qy:, qz:, x:, y:, z:}
    bin_centroid = [bin_pose['x'], bin_pose['y'], bin_pose['z']]
    suction_down_simple(listener = listener, br = br, withPause = withPause, suction_position_target_list = bin_centroid, flag = 0, bin_id = bin_num, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)

def test_all_bins(listener, br, bin_num = 0):
    for bin_num in range(0, 4):
        test_Retry(bin_num = bin_num, listener = listener, br = br)

def test_Retry(listener, br, bin_num = 0, withPause = True):
    suction_position_target_in_list = [[ - 5, - 5, - 5], 
    [5, 5, - 5], 
    [5, - 5, - 5], 
    [ - 5, 5, - 5]]

    print 'hello 2'
    suction_down_simple(listener = listener, br = br, bin_id = bin_num, withPause = withPause, suction_position_target_list = suction_position_target_in_list)
    print 'hello 3'

    time.sleep(.25)
    suction.stop()

def test_ws_check(listener, br, bin_id = 1):
    print 'bin_num = ', bin_id
    bin_pose = rospy.get_param('bin' + str(bin_id) + '_pose')
    bin_centroid = [bin_pose['x'], bin_pose['y'], bin_pose['z']]

    suction_position_target_in_list = [bin_centroid]

    print 'hello 2'

    suction_down_simple(listener = listener, br = br, bin_id = bin_id, withPause = True, flag = 0, suction_position_target_list = suction_position_target_in_list)
    print 'hello 3'

    time.sleep(.25)


def test_collision_free_to_bin7(listener, br, bin_num_1 = 0, bin_num_2 = 7):
    collision_free_placing(binId = bin_num_1, listener = listener, isSuction = True, with_object = True)
    suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 0, bin_id = bin_num_1, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)
    suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 2, bin_id = bin_num_2, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)

def test_safety_height_for_placing(listener, br, bin_num_1 = 0, bin_num_2 = 7):
    suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 0, bin_id = bin_num_1, print_messages = True, rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)
    suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 1, bin_id = 1, print_messages = True, rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)
    suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 2, bin_id = bin_num_2, print_messages = True, obj_ID = 'avery_binder', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)

    #suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 2, bin_id = bin_num_1, print_messages = True, obj_ID = 'composition_book', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)
    #suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 2, bin_id = bin_num_2, print_messages = True, obj_ID = 'composition_book', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)

def test_collision_free_to_bins(listener, br):

    test_collision_free_to_bin7(listener, br, bin_num_1 = 0, bin_num_2 = 6)
    test_collision_free_to_bin7(listener, br, bin_num_1 = 0, bin_num_2 = 7)
    test_collision_free_to_bin7(listener, br, bin_num_1 = 0, bin_num_2 = 8)
    test_collision_free_to_bin7(listener, br, bin_num_1 = 3, bin_num_2 = 6)
    test_collision_free_to_bin7(listener, br, bin_num_1 = 3, bin_num_2 = 7)
    test_collision_free_to_bin7(listener, br, bin_num_1 = 3, bin_num_2 = 8)

def test_picking(withPause = True):
    suction_down_simple(listener = listener, br = br, withPause = withPause, suction_position_target_list = [ - 3, - 5, - 5], flag = 0, bin_id = 3, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)
    #~ suction_down_simple(listener = listener, br = br, withPause = withPause, suction_position_target_list = [ - 3, - 5, - 5], flag = 1, bin_id = 1, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)
    suction_down_simple(listener = listener, br = br, withPause = withPause, suction_position_target_list = [ - 3, - 5, - 5], flag = 2, bin_id = 1, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)

    #####################################
    # Full Unit Test before competetion #
    #####################################
def unit_test_suction(listener,br,withPause=True):
    stowing_bin_set = [0,1,2,3,6,7,8]
    pick_bin_set = [4,5]
    
    ########## for stowing test ###############
    # test picking from centers and corners
    for bin_num in stowing_bin_set:
        rospy.logwarn('[Test] Reaching center of bin_%d',bin_num)
        test_center_of_bin(listener=listener, br=br, bin_num = bin_num, withPause = withPause)
        rospy.logwarn('[Test] Reaching corners of bin_%d',bin_num)
        test_Retry(listener=listener, br=br, bin_num = bin_num, withPause = withPause)
    
    #~ # test collision_free_placing
    for bin_from in range(0,4):
        for bin_to in stowing_bin_set:
            rospy.logwarn('[Test] From bin_%d to bin_%d',bin_from,bin_to)
            collision_free_placing(binId = bin_from, listener = listener, isSuction = True, with_object = False)
            test_precise_placing(listener = listener, br = br, bin_id = bin_to,withPause=withPause)
            if bin_to > 5:
                go_arc_safe(isSuction=True)
    
    ########## for picking test ###############
    # test collision_free_placing
    for bin_from in range(1,4):
        for bin_to in pick_bin_set:
            rospy.logwarn('[Test] From bin_%d to bin_%d',bin_from,bin_to)
            collision_free_placing(binId = bin_from, listener = listener, isSuction = True, with_object = False)
            test_precise_placing(listener = listener, br = br, bin_id = bin_to,withPause=withPause)

if __name__ == "__main__":
    listener = tf.TransformListener()
    br = tf.TransformBroadcaster()
    go_arc_safe(isSuction=True)
    rospy.sleep(0.5)
    
    
    unit_test_suction(listener = listener, br = br,withPause=False)
    
    #rospy.init_node('suction_down_simple')


    #suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target = [3.972135, - 0.5685, - 5], 
    #flag = 2, bin_id = 0, print_messages = True)

    #suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target = [3.972135, - 0.5685, - 5], 
    #flag = 2, bin_id = 3, print_messages = True)

    #print("Testing Suction Down Simple with Flag 3")
    #~ #suction_down_simple(flag = 3)

    #~ for side in range(0,4):
        #~ #test_tilt0(bin_num = 0, br = br, listener = listener, side = side)
        #~ test_tilt1(bin_num = 1, br = br, listener = listener, side = side)

    #test_point = [1.1401540040969849, -0.52592861652374268, -0.09357592880725861]

    #suction_down_simple(listener, br, suction_position_target_list = test_point, 
    #flag = 0, bin_id = 0)
    #for bin_num in xrange(2, 4):

    #~ test_Retry(bin_num = 2, br = br, listener = listener)
    #~ test_ws_check(bin_id = 1, br = br, listener = listener)

    #test_all_bins(bin_num = 0, listener = listener, br = br)


    #test_center_of_bin(bin_num = 0, listener = listener, br = br)



    #~ test_precise_placing(listener = listener, br = br, obj_ID = 'avery_binder', bin_id = 8,go_faster_flag=True)
    #~ go_arc_safe(isSuction=True)
    #~ test_precise_placing(listener = listener, br = br, obj_ID = 'avery_binder', bin_id = 8,go_faster_flag=False)

    #~ unit_test_placing(listener = listener, br = br)
    
    #test_collision_free_to_bins(listener, br)



    #~ test_safety_height_for_placing(listener, br, bin_num_1 = 0, bin_num_2 = 2)



    #test_picking(withPause = False)

    #~ suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 0, bin_id = 1, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)

    #test_safety_height_for_placing(listener, br, bin_num_1 = 0, bin_num_2 = 1)

    #test_safety_height_for_placing(listener, br, bin_num_1 = 0, bin_num_2 = 1)

    #~ suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 1, bin_id = 0, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)


    #suction_down_simple(listener = listener, br = br, withPause = True, suction_position_target_list = [ - 3, - 5, - 5], flag = 1, bin_id = 0, print_messages = True, obj_ID = 'expo_eraser', rel_pose = None, BoxBody = None, place_pose = None, box_height = 0.1)

    #test_bounds(listener = listener, br = br, bin_num = 0, pos_num = 1)
    #test_bounds(listener = listener, br = br, bin_num = 0, pos_num = 0)
    #test_bounds(listener = listener, br = br, bin_num = 0, pos_num = 2)
    #test_bounds(listener = listener, br = br, bin_num = 0, pos_num = 3)

    #print("Test Drop")
    #test_drop(listener = listener, br = br, )
    #print("Test Base")
    #test_base(listener = listener, br = br, )
    go_arc_safe(isSuction=True)
